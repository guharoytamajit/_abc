
setup:
>npm install -g @angular/cli
>ng new first-app
>cd first-app
>ng serve


set yarn as package manager:
>ng config -g cli.packageManager yarn
===================================================================================

generate date component:
>ng generate component date

date.component.ts:

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-date',
  
template: `date:  {{date}}`,
  
styleUrls: ['./date.component.css']
})

export class DateComponent  {

public date:Date;
  
constructor() {
    
setInterval(()=>{this.date=new Date();},1000);
   
}
}


make sure you have added <app-date></app-date> inside app.component.html
===================================================================================
interpolation and [] can both do broperty binding,but interpolation will not work with non string type for example

<input disabled="{{false}}">  #does not work
<input [disabled]="false">    #it works


Interpolation and [] can work with variable,value or expression

eg.  <input [value]="2+2"/>   #expression
     <input [value]="msg"/>   #component variable ie.property of class
     <input [disabled]="false"/>  #assigning value

<input value="{{2+2}}">
<input value="{{msg}}"/> 
<input value="{{'ggg'}}"/ > # altough this is not very useful we can do the same using <input value='ggg'/ >

===================================================================================
Attribute vs Property
Attribute=> the initial value.
Property=current dom value

For example:
<input value="hello">
here attribute value will be always equalto "hello"
but property value can change if user changes it from form.
===================================================================================
class binding:

<h2 [class]="myclass" >hello</h2>  #my class is the variable holding the class name as value

Note if we have class attribute and class binding together then class binging will overwrite class attribute.
<h2 class="special-text" [class]="myclass" >hello</h2>  #here class="special-text" will have no effect, so dont use them together.


conditionnl apply a single class:
<h2 [class.special-text]="special">hello</h2>  #here .special-text class is applied if special component property is true.special is a boolean variable.

conditionnl apply multiple classes:
<h2 [ngClass]="messageClasses">hello</h2>  #where messageClasses is a json component property,where keys are class name and values are true or false.we can make true/false dynamic by using 


public messageClasses={
"text-success":this.isSuccess,
"text-special":this.isSpecial,
}
=======================================================================================
style binding:
<h2 [style.color]="'orange'" >hello</h2> #static binding
Or
<h2 [style.color]="myColor" >hello</h2>  #dynamic binding, here myColor is component property

conditional style binding:
<h2 [style.color]="hasError ? 'red':'green'">

Apply multiple styles:
<h2 [ngStyle]="titleStules">hello</h2>


titleStules={
color:"blue",
fontStyle:"italic"
}
===
<p [ngStyle]="{backgroundColor:getColor()}"></p>

Or

<p [ngStyle]="{backgroundColor:color=='red'?'red':'green'}"></p>
===============================================================================================
event binding:
Lets change component property in two different ways using event binding:
<button (click)="onClick()">Button1</button>

<button (click)="msg='hello world'">Button2</button>
{{msg}}

inside component add:
  onClick(){
    this.msg="world";
  }

===============================================================================================
template reference: very similar to shortcut of get emement by id.

in template:
<input #myInput type="text">
<button (click)="logValue(myInput)">log</button>

in component:
logValue(input){
console.log(input.value)
}
================================================================================
If display property is true display first template else display 2nd template:
<div *ngIf="display;then thenBlock;else elseBlock"></div>
<ng-template #thenBlock>hello</ng-template>
<ng-template #elseBlock>world</ng-template>
================================================================================
<div [ngSwitch]="myColor">
<div *ngSwitchCase="'red'">you selected red</div>
<div *ngSwitchCase="'blue'">you selected blue</div>
<div *ngSwitchCase="'green'">you selected green</div>
<div *ngswitchDefault>No match found</div>
</div>
================================================================================
<div *ngFor="colour of colors;index as i">
{{i}} {{color}}
</div>

like index there are few other implic variables like first,last,odd,even
where myColor is a compont property,which can have values like red.
=================================================================================

<input (input)="onInput($event)">

here $event represent input element inside onInput() we can get value of input field as:

onInput(event){
console.log(event.target.value);
}
===============
Another way to pass an element to function is by using local reference(using #)

<input #myInput>
<button (click)="myMethod(myInput)">submit</button>

==============
Another way of doing the same is by using @ViewChild

Add component property:

@ViewChild("myInput") myProperty:ElementRef;

console.log(this.myProperty.nativeElement.value)  #we can access value like this
In template:
<input #myInput>


We can pass data from form to component using local-reference or @ViewChild or [(ngModel)].
ngModel will do 2 way binding with a component property where as in local-reference we have to pass the element as function parameter.When using @ViewChild we don't have to pass element as function  parameter.
===================================================================================

parent child component interaction:

app.component.html:
{{message}}
<app-child (childEvent)="message=$event" [parentData]="name"/></app-child>  #here $event is not Event object but value emitted from child component ie. childEvent.emit('hi parent')

app.component.ts:

public name="joe";
public message="";


child.component.ts:

@Input() public parentData;
@Output() public childEvent=new EventEmitter();
fireEvent(){
this.childEvent.emit('hi parent')
} 

child.component.ts:
{{'hello' +name}}
<button (click)="fireEvent()">sent to parent</button>

========================================================
<ng-content></ng-content> can be used in the template to load the body of component tag



============================================
Pipe:
{{name | lowercase}}
{{name | uppercase}}
{{name | titlecase}}
{{massage | slice:2:5}} #slice with provided from index to before index
{{person | json}}

{{5.678 |1.2-3}}  #5.678
{{5.678 |3.4-5}}  #005.6780
{{5.678 |3.1-2}}  #005.68  notice it is rounding here




{{0.25 | percent}}
{{0.25 | currency}}

{{date | date:'short'}}
{{date | date:'shortDate'}}
{{date | date:'shortTime'}}
{{0.25 | currency: 'GBP'}}
========================
Before injecting services add it as providers in app modele.
@Injectable() decorator tells it may have dependencies

======================
httpclient:
in module > imports add HttpClientModule from @angular/common/http

inject httpclient inside service and use it:

import 'rxjs/add/operator/catch';
import 'rxjs/add/observable/throw'

 constructor(private http:HttpClient){}
 getEmployees(): Observable<IEmployee[]>{
 return this.http
            .get<IEmployee[]>("/assets/data/employee.json")
            .catch(this.errorHandler);
}
errorHandler(error:HttpErrorResponse){
 return Observable.throw(error.message || 'server error');
}

Inside component:

ngOnInit(){
this.employeeService.getEmployees().subscribe(data=> this.empList=data,
                                              error=>this.errorMsg=error);
}


==================================
Interceptors:

@Injectable()
export class I1 implements HttpInterceptor {
    intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
        const modified = req.clone({setHeaders: {'Custom-Header-1': '1'}});
        return next.handle(modified);
    }
}

@NgModule({
    imports: [BrowserModule, HttpClientModule],
    declarations: [AppComponent],
    providers: [
        {
            provide: HTTP_INTERCEPTORS,
            useClass: I1,
            multi: true
        }
    ],
    bootstrap: [AppComponent]
})
export class AppModule {}

@Component({
    selector: 'my-app',
    template: `
        <div><h3>Response</h3>{{response|async|json}}</div>
        <button (click)="request()">Make request</button>`
    ,
})
export class AppComponent {
    response: Observable<any>;
    constructor(private http: HttpClient) {}

    request() {
        const url = 'https://jsonplaceholder.typicode.com/posts/1';
        this.response = this.http.get(url, {observe: 'body'});
    }
}
=============================
Routing:
RouterModule.forRoot(routes)
const routes:Routes=[
{path:'user',component:UserComponent,children:[
  {path:':id',component:UserDetailComponent}
 ]},
{path:"" redirectTo="/user" pathMatch=""},
{path:'**',component:PageNotFoundCompinent}
]
<router-outlet></router-outlet> sould be present in app and user template, it is a placeholder that Angular dynamically fills based on the current router state
r:Router;  r.navigate(['user','detail']) #by default not relative(absolute)
r.navigate(['user','detail'],{relativeTo:this.activeRoute}) #to make it relative
r.navigate(['user','detail'],{relativeTo:this.activeRoute,queryParams:{user:'tamajit'},fragment:'abc'}) #to make it relative
r.navigate(['user','detail'],{relativeTo:this.activeRoute,queryParamsHandling:'merge'})//queryParamsHandling=merge ie. 'merge' previous routes queryParam with new.Similarly you can pass queryParamsHandling:'preserve' to preserve previous routes  queryParams
ar:ActivatedRoute
this.ar.snapshot.params['id']  #this changes will not reflect if from component and to components are same using routerLink(ose observable based approach instead)
this.ar.params.subscribe((params:Params)=>{this.id=params['id']); // no need to unsubscribe them manually angular will do it for us
similarly use this.ar.queryParams and this.ar.fragment  
[routerLink]="['/user','detail']"
routerLinkActive="class"
[routerLinkOption]="{exact:true}"
[queryParams]="{name:'tamajit'}"        //query parameters for routerLink 
fragment="abc"                         //adds #abc at he end of url formed by routerLink 

==================================
HttpModule vs HttpClientModule:
HttpClient supports generics,interceptor
