The agent section specifies where the entire Pipeline, or a specific stage, will execute in the Jenkins environment depending on where the agent section is placed.
The section must be defined at the top-level inside the pipeline block, but stage-level usage is optional.

You can Set a label under the Configuration of the Node. You can use a label in your pipeline like:

pipeline {
agent { label 'labelName' }
(...)
}


'agent any'  means Execute the Pipeline, or stage, on any available agent.

--------------------------------
jenkins pipeline: agent vs node?


The simple answer is, Agent is for declarative pipelines and node is for scripted pipelines.

In declarative pipelines the agent directive is used for specifying which agent/slave the job/task is to be executed on. This directive only allows you to specify where the task is to be executed, which agent, slave, label or docker image.

On the other hand, in scripted pipelines the node step can be used for executing a script/step on a specific agent, label, slave. The node step optionally takes the agent or label name and then a closure with code that is to be executed on that node.

--------------------------------------------
https://devopscube.com/setup-slaves-on-jenkins-2/



One of the best features of Jenkins is its distributed nature. You can configure multiple build slaves for better segregation and scalability. For example, you might want to test a cross-platform code base with a different operating system. In this case, you can configure different OS slaves and run the job against them. Also, a distributed architecture will reduce the load on the master server.

ssh plugin must be installed in jenkins

On slave node:
1)install ssh
apt-get update && apt-get install -y openssh-server

2)create user:
sudo adduser jenkins --shell /bin/bash

3)Create a “jenkins_slave” directory under /home/jenkins.

mkdir /home/jenkins/jenkins_slave


todo

-----------------------------------------------------

Docker based agent:

pipeline {
    agent {
        docker { image 'node:14-alpine' }
    }
    stages {
        stage('Test') {
            steps {
                sh 'node --version'
            }
        }
    }
}

Jenkins workspace:
The workspace directory is where Jenkins builds your project: it contains the source code Jenkins checks out, plus any files generated by the build itself. This workspace is reused for each successive build.

By default, for containerized stage, Jenkins does:
pick any agent,
create new empty workspace,
clone pipeline code into it,
mount this new workspace into container.

If you have multiple Jenkins agents, your containerized stage can be started on any of them.

When reuseNode set to true: no new workspace will be created, and current workspace from current agent will be mounted into container, and container will be started at the same node, so whole data will be synchronized.

pipeline {
    agent any
    stages {
        stage('Build') {
            agent {
                docker {
                    image 'gradle:6.7-jdk11'
                    // Run the container on the node specified at the top-level of the Pipeline, in the same workspace, rather than on a new node entirely:
                    reuseNode true
                }
            }
            steps {
                sh 'gradle --version'
            }
        }
    }
}


Caching data for containers:
We can cache by mouting volume using -v source:destination  argument

pipeline {
    agent {
        docker {
            image 'maven:3.8.1-adoptopenjdk-11'
            args '-v $HOME/.m2:/root/.m2'
        }
    }
    stages {
        stage('Build') {
            steps {
                sh 'mvn -B'
            }
        }
    }
}


Using different containers for different stages:
pipeline {
    agent none
    stages {
        stage('Back-end') {
            agent {
                docker { image 'maven:3.8.1-adoptopenjdk-11' }
            }
            steps {
                sh 'mvn --version'
            }
        }
        stage('Front-end') {
            agent {
                docker { image 'node:14-alpine' }
            }
            steps {
                sh 'node --version'
            }
        }
    }
}	

Build agent from a dockerfile (instead of image):

pipeline {
    agent { dockerfile true }
    stages {
        stage('Test') {
            steps {
                sh 'node --version'
                sh 'svn --version'
            }
        }
    }
}

---Dockerfile---
FROM node:14-alpine
RUN apk add -U subversion





