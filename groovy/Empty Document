use groovysh to open interactive groovy console(REPL),like node
>1+1
>System.out.println("hello");
>println("hello")  //groovy uses meta programming to add println() to object class ,so directly accessible
>println "hello"   //parenthesis are optional here
>println 'hello'    //normal string(java.lang.String) uses single quote, using double quote we define gstring which allows interpolation( ${placeholder} )


​void greet(String name){
println "hello, ${name}"
}
myname='tamajit'
greet(myname)​

O/P=> hello, tamajit
============
execute a groovy file:
>groovy file.groovy  #compiled and executed in same step

only compile:
>groovy file.groovy  #produces .class

run class generated by groovy:
>java -cp $Groovy_HOME/embeddable/groovy-all*.jar:. hello_world
==============
assert 9 == 7+2

====
we can ignore datatypes like int ,String and just define of def type

def i=10  //we use def when either we dont know the datatype or dont care what the datatype is
println i.getClass().getName()  // java.lang.Integer
i='abc'    //we can change the datatype of def, we cannot de this we it was declared to be a static type
println i.getClass().getName()  // java.lang.String


if we dont declare the types in method args by default it is of type def
==============
3.getClass().getName() // in groovy int is actually a wrapper
o/p=> java.lang.Integer
(3.5).getClass().getName()
o/p=> java.math.BigDecimal  //even small decimals are not float to prevent precision loss
================
operater operloading (+,-,=,<< etc)
attribute(fields) vs property
=================
collections:

range
Range r=1..10
String s='hello world'[0..4]

list
List l=[2,3,4]                //creates ArrayList  
def ll=[2,3,4] as LinkedList  //creates Linkedlist
def s=[2,3,4,2] as Set  //creates LinkedHashSet ,it will remove duplicates
def ss=[8,2,3,4] as SortedSet  //creates TreeSet ,it will remove duplicates and sort

def array="hello world".split() // creates array of string
List list="hello world".split() // only if return type is changes,groovy will create list instead of array

map
def m=[a1:'apple',b:'ball',2:"two"] // keys are string, no need for quote
m.put('h','hello')
m['d']='doll'
m.e='ear'  //here '.' is operator overloaded hence cannot use "m.class.name" with map , use m.getClass().name instead
m




===============
groovy bean:
class public by default,
fields private by default,
public getter-setter generated by default,
emp.lastName=1 actually calls emp.SetLastName(1)



========
closure:
like method body,without name,default attribute name is 'it' if not explicitly provided.
examples:
(10..5).each{println it }
(10..5).each{val->println " $val" }
(10..5).eachWithIndex{val,idx->println "$idx => $val" }
[a1:'apple',b:'ball',2:"two"].each{k,v->println "$k => $v"}
[a1:'apple',b:'ball',2:"two"].each{entry->println "$entry.key => $entry.value"}

If you have a method whose last argument is a closure, then we generally put the closure after parenthesis.
example: Number.downto(Number to,Closure closure)

10.downto(7,{println it}) //speaking groovy in java accent
10.downto(7){println it} //idiomatic groovy
10.downto 7, {println it} //without parenthesis

[1,2,3,4].collect{it*2}// [2,4,6,8] like map
[1,2,3,4].findAll{it %2 ==0 } //[2,4] like filter
[1,2,3,4].sum() //10
['good','morning']*.size() //[4,7]  //* is called spread operator ,like a short hand of collect method
[a:'apple',b:'ball'].collect{k,v-> "$k=$v"} //[a=apple, b=ball],  transformed a map to list of string
[a:'apple',b:'ball'].collect{k,v-> "$k=$v"}.join('&')// convert a map to query string for http
==============
Safe navigation:

class Department{
Manager boss
}

class Manager{
String name
}
def d =new Department(boss: new Manager(name: 'jack'))
println d.boss.name
println d?.boss?.name// NullPointerException safe,returns null instead of NPE
----
Spaceship operator:
def a=9
def b=8
a <=> b //if a> b return +1,if a==b return 0, if a<b return -1

=====

Xml parse:
<people>
 <person id=1>
  <name>john</name>
 </person>
 <person id=2>
  <name>john</name>
 </person>
</people>


def root=new XmlSlurper().parse('people.xml') //here you can also pass http url eg. parse("http://abc.com.people.xml")
println "second name: ${root.person[1].name}"
println "first id: ${root.person[0].@id}"

==========
json parsing:
[
{"name":"john",role:"manager"},
{"name":"jim",role:"developer"}
]


import groovy.json.*
String jsonText=new File('people.json').text
def json =new JsonSlurper().parseText(jsonText)
assert json[1].role == 'developer'
=====
generate xml:

def builder=new groovy.xml.MarkupBuilder()
builder.people{                            //people method takes single arguement ie Closure
 person(id:1){                             //person method takes two arguements ie map and Closure
  name: 'john'                              //name method takes a single arguement ie. string 
 }
 person(id:2){
  name: 'jim'
 }
}

O/P=>
<people>
 <person id=1>
  <name>john</name>
 </person>
 <person id=2>
  <name>john</name>
 </person>
</people>
==================
generate json:

import groovy.json.*
def builder=new JsonBuilder()
builder([name:"john",role:"manager"],[name:"john",role:"developer"]) 
assert builder.toString() =='[{name:"john",role:"manager"},{name:"john",role:"developer"}]'
================
Metaprogramming:

Expando is a groovy class which donot have any property but we can add any property.
But added properties to an object only belong to that object of that Expando,not other Expando objects

Expando e=new Expando()
e.name='fido'
e.speak={"$name says woof"} //assign a closure
e

Every class has a metaclass and that metaclass is Expando















































